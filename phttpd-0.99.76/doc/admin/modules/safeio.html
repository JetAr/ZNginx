<HTML>
<HEAD>
<TITLE>
Phttpd: SAFEIO
</TITLE>
</HEAD>
<BODY>
<H2 ALIGN=CENTER>
The SAFEIO subsystem
</H2>

<B>Safeio</B> is a library of low level system-level cover functions which
should be used instead of the standard ones.

<H3>Functions:</H3>

<DL>

<DT><B>void s_sleep(int timeout)</B>
<DD>Sleep for a number of seconds.


<P><DT><B>void *s_malloc(size_t size)</B>
<DD>Allocate and clear (zero-fill) a block of memory.
	Aborts the process in case of failures.

<P><DT><B>void *s_realloc(void *ptr, size_t size)</B>
<DD>Reallocate a previously allocated block of memory. If the block
is extended, the extra data is cleared (zerofilled).
	Aborts the process in case of failures.

<P><DT><B>void s_free(void *ptr)</B>
<DD>Free a previously allocated block of memory.
	Aborts the process in case of failures.

<P><DT><B>void s_abort(void)</B>
<DD>Abort the current process in such a way that a debugger will stay inside
	the thread that called it.


<P><DT><B>char *s_strdup(const char *str)</B>
<DD>Duplicate a string.



<P><DT><B>int s_open(const char *path, int oflag, mode_t mode)</B>
<DD>Open a file system object.

<P><DT><B>int s_close(int fd)</B>
<DD>Close a descriptor.

<P><DT><B>int s_shutdown(int fd, int how)</B>
<DD>Shutdown a descriptor.

<P><DT><B>int s_connect(int fd, struct sockaddr *sin, int len)</B>
<DD>Connect a socket to a remote endpoint.

<P><DT><B>int s_accept(int fd, struct sockaddr *sin, int *lenp)</B>
<DD>Accept an incoming TCP/IP connection on a socket.

<P><DT><B>int s_ioctl(int fd, int what, void *ptr)</B>
<DD>Perform an ioctl call.

<P><DT><B>int s_select(int nfd, fd_set *rs, fd_set *ws, fd_set *es, struct timeval *tv)</B>
<DD>Wait for I/O events.

<P><DT><B>int s_read(int fd, char *buf, int len)</B>
<DD>Read bytes from a descriptor.

<P><DT><B>int s_write(int fd, const char *buf, int len)</B>
<DD>Write bytes to a descriptor.

<P><DT><B>int s_chdir(const char *path)</B>
<DD>Change current directory.

<P><DT><B>int s_dup2(int fd1, int fd2)</B>
<DD>Duplicate a file descriptor.

<P><DT><B>pid_t s_waitpid(pid_t pid, int *status, int options)</B>
<DD>Wait for a process status to change.

<P><DT><B>int s_execve(const char *path, char *const argv[], char *const envp[])</B>
<DD>Execute a new process.

<P><DT><B>DIR *s_opendir(const char *path)</B>
<DD>Open a directory for reading.

<P><DT><B>int s_closedir(DIR *dirp)</B>
<DD>Close a directory.

<P><DT><B>struct dirent *s_readdir_r(DIR *dirp, struct dirent *res)</B>
<DD>Read the directory contents.

<P><DT><B>struct hostent *s_gethostbyaddr_r(const char *addr,
				  int length,
				  int type,
				  struct hostent *result,
				  char *buffer,
				  int buflen,
				  int *h_errnop)
</B>
<DD>

<P><DT><B>struct hostent *s_gethostbyname_r(const char *name,
				  struct hostent *result,
				  char *buffer,
				  int buflen,
				  int *h_errnop)
</B>
<DD>

<P><DT><B>struct passwd *s_getpwnam_r(const char *name,
				  struct passwd *res,
				  char *buf,
				  int buflen)
</B>
<DD>

<P><DT><B>struct passwd *s_getpwuid_r(int uid,
			    struct passwd *res,
			    char *buf,
			    int buflen)
</B>
<DD>

<P><DT><B>struct group *s_getgrnam_r(const char *name,
			   struct group *res,
			   char *buf,
			   int buflen)
</B>
<DD>

<P><DT><B>int s_readlink(const char *path, char *buf, int buflen)
</B>
<DD>Read a symbolic link pointer.

<P><DT><B>int s_stat(const char *path, struct stat *buf)</B>
<DD>Get file system object status.

<P><DT><B>int s_lstat(const char *path, struct stat *buf)</B>
<DD>Get file system object status (don't follow links).

<P><DT><B></B>
<DD>

</DL>

</BODY>
</HTML>

