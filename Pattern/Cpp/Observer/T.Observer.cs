/* #FH  //z 2015-04-01 15:47:22 L.274'29558 BG57IV3@XCL T1705473424.K.F1369709719----+----+----+
+  0.FileInfo: +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
        File : E:\MyDoc\GitHub\ZNginx\Pattern\Cpp\Observer\T.Observer.cs.F1369709719-+----+----+
       Motto : No one can make you feel inferior without your consent.+----+----+----+----+----+
       Motto : The death of fear is in doing what you fear to do.+----+----+----+----+----+----+
       Motto : It's hard to beat a person who never gives up.----+----+----+----+----+----+----+
       Motto : Take what you do seriously. Not yourself.----+----+----+----+----+----+----+----+
       Motto : Life begins where your comfort zone ends.----+----+----+----+----+----+----+----+
       Motto : To know and not do, is not yet to know.-+----+----+----+----+----+----+----+----+
       Motto : The more you do , the more you can do.--+----+----+----+----+----+----+----+----+
       Motto : Do what you do best, better.--+----+----+----+----+----+----+----+----+----+----+
       Motto : Get Your Hands Dirty.----+----+----+----+----+----+----+----+----+----+----+----+
      Author : 126.org@gmail.com (R) Kaizen (->30,T5,M&M,W)-+----+----+----+----+----+----+----+

+  1.ID & Desc: ----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  2.Req & Repro: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  3.Folder & File: +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  4.Cause & Solution: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  5.Todo & Done: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  6.Commit: --+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  7.Issue: ---+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  8.Summary: -+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

+  9.Misc: ----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+

***********************************************************************************************/

#region 04-01 15:47 R#.0    @Ver.Info
       Zey_S : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
		R#
       Zey_E : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
       Zcl_S : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
       Zcl_E : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     Zndex_S : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
      L69 ,  1:R#.1    @observer pattern
      L222,  2:R#.2    @Chapter 18: The Observer Pattern
     Zndex_E : //z 2015-04-18 22:43:56 L.257'4564  T211750969 .K ~93  +----+----+----+----+----+
     TimeCnt : //z 2015-04-01 16:05:47 L.274'28453 T2992125906.K ~5   +----+----+----+----+----+
     Reg.Cnt : //z 2015-04-01 16:02:09 L.274'28671 T2992017965.K ~2   +----+----+----+----+----+
     #2   R+ : //z 2015-04-01 16:02:09 L.274'28671 T2992017965.K ~2     V+.73   L+.216  
     #1   R+ : //z 2015-04-01 15:47:27 L.274'29553 T1705473429.K ~1     V+.3    L+.62   
     File.Op : //z 2015-04-18 22:43:19 L.257'4601  T211750840 .K ~1   +----+----+----+----+----+
     #1   O+ : //z 2015-04-18 22:43:19 L.257'4601  T211750840 .K ~1     V+.95   L+.1    
     Version : //z 2015-04-18 22:43:56 L.257'4564  T211750969 .K ~95    R+.1    L+.77   --+----+
     #5   V+ : //z 2015-04-18 22:43:56 L.257'4564  T211750969 .K ~95    R+.1    L+.77   
     #4   V+ : //z 2015-04-01 16:02:30 L.274'28650 T2992018055.K ~76    R+.2    L+.218  
     #3   R+ : //z 2015-04-01 16:02:09 L.274'28671 T2992017965.K ~73    R+.2    L+.217  V+.73   
     #3   V+ : //z 2015-04-01 15:57:29 L.274'28951 T1706659352.K ~57    R+.1    L+.202  
     #2   V+ : //z 2015-04-01 15:51:54 L.274'29286 T1706443824.K ~38    R+.1    L+.116  
     #1   V+ : //z 2015-04-01 15:49:03 L.274'29457 T1705545233.K ~19    R+.1    L+.97   
     #0   R+ : //z 2015-04-01 15:47:27 L.274'29553 T1705473429.K ~3     R+.1    L+.63   V+.3    
     K   Ter : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K  Mers : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K Kersi : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     KVersio : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K Versi : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K  Vers : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K   Ver : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K    Ve : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
     K     V : //z 2015-04-01 16:02:09 L.274'28671 T2992017965.K ~73    R+.2    L+.217  
     KaizenZ : //z 2015-04-01 15:47:22 L.274'29558 T1705473424.K ~0   +----+----+----+----+----+
#endregion //z 2015-04-01 15:47:22 L.274'29558 BG57IV3@XCL T1705473424.K.F1369709719-+----+----+

#region 04-01 15:47 R#.1    @observer pattern
//z 2015-04-01 16:05:47 L.274'28453 T2992125906.K[T5,L68,R1,V82]
00. 看了下 r 1 & 2 这两个例子，发现基本的思路都是将notify func 存储到一个vec中去；在事物变化时，
通知调用对应的类。

//z 2015-04-01 15:47:51 L.274'29529 T1705473522.K[T1,L62,R1,V7]
01. 意图。
int main()
{
    Subject s;
    Observer o1 = ....;
    Observer o2 = ....;
    Observer o3 = ....;

    s.registerObserver(EventA, o1);
    s.registerObserver(EventB, o3);
    s.registerObserver(EventD, o1);
    s.registerObserver(EventB, o2);
    s.registerObserver(EventC, o3);

    s.notify(EventB); // notify all observers registered for EventB
    s.notify(EventC); // notify all observers registered for EventC
}

//z 2015-04-01 15:48:21 L.274'29499 T1705509360.K[T2,L81,R1,V12]
The general structure has

Subject: accepts registration requests according to some key or event. Notifies observers reigstered for a given event.
Observers: register themselves to be notified by the observer for a given eventSubject
Events: Act as registration key and trigger for notification

enum class Event { RED, GREEN, BLUE, ORANGE, MAGENTA, CYAN };

class Observer; // a passible subscriber callback class

class Subject
{
public:
    void registerObserver(const Event& event, const Observer& observer);
    void notify(const Event& event) const;
};

//z 2015-04-01 15:49:05 L.274'29455 T1705545235.K[T3,L100,R1,V20]
#include  <functional> // for std::function
#include <vector>
#include <map>
#include <utility>     // for std::forward
class Subject
{
public:
    //z 
    template <typename Observer>
    void registerObserver(const Event& event, Observer&& observer)
    {
        //z 这里 forward 是什么意思了？
        observers_[event].push_back(std::forward<Observer>(observer));
    }

    // other methods as before
private:
    //z 使用一个来map来存储对应的关心这个的响应的函数等信息。
    std::map<Event, std::vector<std::function<void()>>> observers_;
};

class Subject
{
    ...
    void notify(const Event& event)
    {
        //z 通知对应的消息。
        for (const auto& obs : observers_[event]) obs();
    }
    ...
};

#include "Subject.h"   // for our Subject class
#include <functional>  // for std::function and std::bind
#include <iostream>

void foo(int i)
{
    std::cout << "foo( " <<  i << " )\n";
}

void bar()
{
    std::cout << "bar()\n";
}

int main()
{

    Subject s;
    s.registerObserver(Event::GREEN, bar);
    s.registerObserver(Event::ORANGE, std::bind(foo, 42));
    s.registerObserver(Event::RED, std::bind(foo, 12345));

    s.notify(Event::GREEN);
    s.notify(Event::RED);
    s.notify(Event::ORANGE);

}

#include <functional>  // for std::function
#include <utility>     // for std::forward and std::move
#include <map>
#include <vector>

template <typename Event>
class Subject
{
public:
    //z 这些新的 && 操作符的意义是啥？2015-04-01 15:56
    template <typename Observer>
    void registerObserver(const Event& event, Observer&& observer)
    {
        observers_[event].push_back(std::forward<Observer>(observer));
    }

    template <typename Observer>
    void registerObserver(Event&& event, Observer&& observer)
    {
        observers_[std::move(event)].push_back(std::forward<Observer>(observer));
    }

    void notify(const Event& event) const
    {
        for (const auto& obs : observers_.at(event)) obs();
    }

private:
    std::map<Event, std::vector<std::function<void()>>> observers_;
};

int main()
{

    Subject<std::string> s;
    s.registerObserver("GREEN", bar);
    s.registerObserver("ORANGE", std::bind(foo, 42));
    s.registerObserver("RED", std::bind(foo, 12345));

    const std::string msg("Hello, RED!");
    //z lambda 表达式
    s.registerObserver("RED", [&msg] {std::cout << msg << std::endl;});

    //z 通知各个关心的对象。
    s.notify("GREEN");
    s.notify("RED");
    s.notify("ORANGE");
}
#endregion //z 2015-04-01 15:47:27 L.274'29553 BG57IV3@XCL T1705473429.K.F1369709719-+----+----+

#region 04-01 16:02 R#.2    @Chapter 18: The Observer Pattern
01. Design Patterns Explained C++ Code Examples
//z 2015-04-01 16:02:11 L.274'28669 T2992017990.K[T4,L217,R2,V75]
Example 18-1:
Observer Implemented TOC
Customer
Observer
AddrVerification
WelcomeLetter
CustomerTOP

Customer.h
#pragma once
#include
#include
#include "Observer.h"
using namespace std;

class Customer
{
public:
    Customer(void);

    void attach( Observer *myObserver);
    void detach( Observer *myObserver);
    string* getState();
    void notifyObs();
private:
    vector myObs;
public:
    ~Customer(void);
};
Customer.cpp
#include "Customer.h"

Customer::Customer(void)
{
}

Customer::~Customer(void)
{
}

void Customer::attach( Observer *myObserver)
{
    myObs.push_back( myObserver);
}

void Customer::detach( Observer *myObserver)
{
    for (int i= 0; i< myObs.size(); i++)
    {
        if (myObs[i]== myObserver)
        {
            myObs.erase(myObs.begin()+i);
            return;
        }
    }
}

void Customer::notifyObs()
{
    // set arg to something that helps
    // tell the Observers what happened
    for (int i= 0; i< myObs.size(); i++)
    {
        myObs[i]->update(this);
    }
}

string* Customer::getState()
{
    string *state= new string;

    // set state

    return 0l;
}
ObserverTOP
Observer.h
#pragma once
class Customer;

class Observer
{
public:
    Observer(void);
    virtual void update( Customer *myCust)= 0;
public:
    ~Observer(void);
};
Observer.cpp
#include "Observer.h"

Observer::Observer(void)
{
}

Observer::~Observer(void)
{
}

AddrVerificationTOP
AddrVerification.h
#pragma once
#include "Observer.h"
#include "Customer.h"

class AddrVerification : public Observer
{
public:
    AddrVerification(void);
    void update( Customer *myCust);
public:
    ~AddrVerification(void);
};
AddrVerification.cpp
#include "AddrVerification.h"

AddrVerification::AddrVerification(void)
{
}

AddrVerification::~AddrVerification(void)
{
}

void AddrVerification::update ( Customer *myCust)
{
    // do Address verification stuff here
    // can get more information about customer
    // in question by using myCust
}
Example 18-1:
Observer Implemented TOC
Customer
Observer
AddrVerification
WelcomeLetter
CustomerTOP
Customer.h
#pragma once
#include
#include
#include "Observer.h"
using namespace std;

class Customer
{
public:
    Customer(void);

    void attach( Observer *myObserver);
    void detach( Observer *myObserver);
    string* getState();
    void notifyObs();
private:
    vector myObs;
public:
    ~Customer(void);
};
Customer.cpp
#include "Customer.h"

Customer::Customer(void)
{
}

Customer::~Customer(void)
{
}

void Customer::attach( Observer *myObserver)
{
    myObs.push_back( myObserver);
}

void Customer::detach( Observer *myObserver)
{
    for (int i= 0; i< myObs.size(); i++)
    {
        if (myObs[i]== myObserver)
        {
            myObs.erase(myObs.begin()+i);
            return;
        }
    }
}

void Customer::notifyObs()
{
    // set arg to something that helps
    // tell the Observers what happened
    for (int i= 0; i< myObs.size(); i++)
    {
        myObs[i]->update(this);
    }
}

string* Customer::getState()
{
    string *state= new string;

    // set state

    return 0l;
}
ObserverTOP
Observer.h
#pragma once
class Customer;

class Observer
{
public:
    Observer(void);
    virtual void update( Customer *myCust)= 0;
public:
    ~Observer(void);
};
Observer.cpp
#include "Observer.h"

Observer::Observer(void)
{
}

Observer::~Observer(void)
{
}
AddrVerificationTOP
AddrVerification.h
#pragma once
#include "Observer.h"
#include "Customer.h"

class AddrVerification : public Observer
{
public:
    AddrVerification(void);
    void update( Customer *myCust);
public:
    ~AddrVerification(void);
};
AddrVerification.cpp
#include "AddrVerification.h"

AddrVerification::AddrVerification(void)
{
}

AddrVerification::~AddrVerification(void)
{
}

void AddrVerification::update ( Customer *myCust)
{
    // do Address verification stuff here
    // can get more information about customer
    // in question by using myCust
}
WelcomeLetterTOP
WelcomeLetter.h
#pragma once
#include "Observer.h"
#include "Customer.h"

class WelcomeLetter : public Observer
{
public:
    WelcomeLetter(void);
    void update( Customer *myCust);
public:
    ~WelcomeLetter(void);
};
WelcomeLetter.cpp
#include "WelcomeLetter.h"

WelcomeLetter::WelcomeLetter(void)
{
}

WelcomeLetter::~WelcomeLetter(void)
{
}

void WelcomeLetter::update( Customer *myCust)
{
    // do Welcome Letter stuff
    // here can get more
    // information about customer
    // in question by using myCust
}
< WelcomeLetterTOP
WelcomeLetter.h
#pragma once
#include "Observer.h"
#include "Customer.h"

class WelcomeLetter : public Observer
{
public:
    WelcomeLetter(void);
    void update( Customer *myCust);
public:
    ~WelcomeLetter(void);
};
WelcomeLetter.cpp
#include "WelcomeLetter.h"

WelcomeLetter::WelcomeLetter(void)
{
}

WelcomeLetter::~WelcomeLetter(void)
{
}

void WelcomeLetter::update( Customer *myCust)
{
    // do Welcome Letter stuff
    // here can get more
    // information about customer
    // in question by using myCust
}
#endregion //z 2015-04-01 16:02:09 L.274'28671 BG57IV3@XCL T2992017965.K.F1369709719-+----+----+
