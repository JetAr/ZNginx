//--------------------------------------------------------------------------------------
// File: sdkmeshdump.cpp
//
// DirectX SDK .SDKMESH/.ANIM file content examination utility
//
// SDKMESH format is generated by the legacy DirectX SDK's Content Exporter and
// originally rendered by the DXUT helper class SDKMesh
// http://go.microsoft.com/fwlink/?LinkId=226208
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <memory>

#include <DirectXMath.h>

using namespace DirectX;

//--------------------------------------------------------------------------------------
struct handle_closer { void operator()(HANDLE h) { if (h) CloseHandle(h); } };

typedef public std::unique_ptr<void, handle_closer> ScopedHandle;

inline HANDLE safe_handle( HANDLE h ) { return (h == INVALID_HANDLE_VALUE) ? 0 : h; }

//--------------------------------------------------------------------------------------
namespace DXUT
{
    // .SDKMESH files

    // SDKMESH_HEADER
    // SDKMESH_VERTEX_BUFFER_HEADER header->VertexStreamHeadersOffset
    // SDKMESH_INDEX_BUFFER_HEADER  header->IndexStreamHeadersOffset
    // SDKMESH_MESH                 header->MeshDataOffset
    // SDKMESH_SUBSET               header->SubsetDataOffset
    // SDKMESH_FRAME                header->FrameDataOffset
    // SDKMESH_MATERIAL             header->MaterialDataOffset
    // [header->NonBufferDataSize]
    // { [ header->NumVertexBuffers]
    //      VB data
    // }
    // { [ header->NumIndexBuffers]
    //      IB data
    // }


    // .SDDKANIM files

    // SDKANIMATION_FILE_HEADER
    // BYTE[] - Length of fileheader->AnimationDataSize

    // .SDKMESH uses Direct3D 9 decls, but only a subset of these is ever generated by the legacy DirectX SDK Content Exporter

    // D3DDECLUSAGE_POSITION / D3DDECLTYPE_FLOAT3
    // (D3DDECLUSAGE_BLENDWEIGHT / D3DDECLTYPE_UBYTE4N
    // D3DDECLUSAGE_BLENDINDICES / D3DDECLTYPE_UBYTE4)?
    // (D3DDECLUSAGE_NORMAL / D3DDECLTYPE_FLOAT3, D3DDECLTYPE_FLOAT16_4, D3DDECLTYPE_SHORT4N, D3DDECLTYPE_UBYTE4N, or D3DDECLTYPE_DEC3N [not supported])?
    // (D3DDECLUSAGE_COLOR / D3DDECLTYPE_D3DCOLOR)?
    // (D3DDECLUSAGE_TEXCOORD / D3DDECLTYPE_FLOAT1, D3DDECLTYPE_FLOAT2 or D3DDECLTYPE_FLOAT16_2, D3DDECLTYPE_FLOAT3 or D3DDECLTYPE_FLOAT16_4, D3DDECLTYPE_FLOAT4 or D3DDECLTYPE_FLOAT16_4)*
    // (D3DDECLUSAGE_TANGENT / same as D3DDECLUSAGE_NORMAL)?
    // (D3DDECLUSAGE_BINORMAL / same as D3DDECLUSAGE_NORMAL)?

    enum D3DDECLUSAGE
    {
        D3DDECLUSAGE_POSITION = 0,
        D3DDECLUSAGE_BLENDWEIGHT = 1,
        D3DDECLUSAGE_BLENDINDICES = 2,
        D3DDECLUSAGE_NORMAL = 3,
        D3DDECLUSAGE_TEXCOORD = 5,
        D3DDECLUSAGE_TANGENT = 6,
        D3DDECLUSAGE_BINORMAL = 7,
        D3DDECLUSAGE_COLOR = 10,
    };

    enum D3DDECLTYPE
    {
        D3DDECLTYPE_FLOAT1 = 0,  // 1D float expanded to (value, 0., 0., 1.)
        D3DDECLTYPE_FLOAT2 = 1,  // 2D float expanded to (value, value, 0., 1.)
        D3DDECLTYPE_FLOAT3 = 2,  // 3D float expanded to (value, value, value, 1.)
        D3DDECLTYPE_FLOAT4 = 3,  // 4D float
        D3DDECLTYPE_D3DCOLOR = 4,  // 4D packed unsigned bytes mapped to 0. to 1. range
        // Input is in D3DCOLOR format (ARGB) expanded to (R, G, B, A)
        D3DDECLTYPE_UBYTE4 = 5,  // 4D unsigned byte
        D3DDECLTYPE_UBYTE4N = 8,  // Each of 4 bytes is normalized by dividing to 255.0
        D3DDECLTYPE_SHORT4N   = 10,  // 4D signed short normalized (v[0]/32767.0,v[1]/32767.0,v[2]/32767.0,v[3]/32767.0)
        D3DDECLTYPE_DEC3N = 14,  // 3D signed 10 10 10 format normalized and expanded to (v[0]/511.0, v[1]/511.0, v[2]/511.0, 1)
        D3DDECLTYPE_FLOAT16_2 = 15,  // Two 16-bit floating point values, expanded to (value, value, 0, 1)
        D3DDECLTYPE_FLOAT16_4 = 16,  // Four 16-bit floating point values

        D3DDECLTYPE_UNUSED = 17,  // When the type field in a decl is unused.
    };

#pragma pack(push,4)

    struct D3DVERTEXELEMENT9
    {
        WORD    Stream;     // Stream index
        WORD    Offset;     // Offset in the stream in bytes
        BYTE    Type;       // Data type
        BYTE    Method;     // Processing method
        BYTE    Usage;      // Semantics
        BYTE    UsageIndex; // Semantic index
    };

#pragma pack(pop)

    //--------------------------------------------------------------------------------------
    // Hard Defines for the various structures
    //--------------------------------------------------------------------------------------
    const uint32_t SDKMESH_FILE_VERSION = 101;
    const uint32_t MAX_VERTEX_ELEMENTS = 32;
    const uint32_t MAX_VERTEX_STREAMS = 16;
    const uint32_t MAX_FRAME_NAME = 100;
    const uint32_t MAX_MESH_NAME = 100;
    const uint32_t MAX_SUBSET_NAME = 100;
    const uint32_t MAX_MATERIAL_NAME = 100;
    const uint32_t MAX_TEXTURE_NAME = MAX_PATH;
    const uint32_t MAX_MATERIAL_PATH = MAX_PATH;
    const uint32_t INVALID_FRAME = uint32_t(-1);
    const uint32_t INVALID_MESH = uint32_t(-1);
    const uint32_t INVALID_MATERIAL = uint32_t(-1);
    const uint32_t INVALID_SUBSET = uint32_t(-1);
    const uint32_t INVALID_ANIMATION_DATA = uint32_t(-1);
    const uint32_t INVALID_SAMPLER_SLOT = uint32_t(-1);
    const uint32_t ERROR_RESOURCE_VALUE = 1;

    template<typename TYPE> bool IsErrorResource(TYPE data)
    {
        if ((TYPE) ERROR_RESOURCE_VALUE == data)
            return true;
        return false;
    }

    //--------------------------------------------------------------------------------------
    // Enumerated Types.  These will have mirrors in both D3D9 and D3D11
    //--------------------------------------------------------------------------------------
    enum SDKMESH_PRIMITIVE_TYPE
    {
        PT_TRIANGLE_LIST = 0,
        PT_TRIANGLE_STRIP,
        PT_LINE_LIST,
        PT_LINE_STRIP,
        PT_POINT_LIST,
        PT_TRIANGLE_LIST_ADJ,
        PT_TRIANGLE_STRIP_ADJ,
        PT_LINE_LIST_ADJ,
        PT_LINE_STRIP_ADJ,
        PT_QUAD_PATCH_LIST,
        PT_TRIANGLE_PATCH_LIST,
    };

    enum SDKMESH_INDEX_TYPE
    {
        IT_16BIT = 0,
        IT_32BIT,
    };

    enum FRAME_TRANSFORM_TYPE
    {
        FTT_RELATIVE = 0,
        FTT_ABSOLUTE,		//This is not currently used but is here to support absolute transformations in the future
    };

    //--------------------------------------------------------------------------------------
    // Structures.
    //--------------------------------------------------------------------------------------
#pragma pack(push,8)

    struct SDKMESH_HEADER
    {
        //Basic Info and sizes
        UINT Version;
        BYTE IsBigEndian;
        UINT64 HeaderSize;
        UINT64 NonBufferDataSize;
        UINT64 BufferDataSize;

        //Stats
        UINT NumVertexBuffers;
        UINT NumIndexBuffers;
        UINT NumMeshes;
        UINT NumTotalSubsets;
        UINT NumFrames;
        UINT NumMaterials;

        //Offsets to Data
        UINT64 VertexStreamHeadersOffset;
        UINT64 IndexStreamHeadersOffset;
        UINT64 MeshDataOffset;
        UINT64 SubsetDataOffset;
        UINT64 FrameDataOffset;
        UINT64 MaterialDataOffset;
    };

    struct SDKMESH_VERTEX_BUFFER_HEADER
    {
        UINT64 NumVertices;
        UINT64 SizeBytes;
        UINT64 StrideBytes;
        D3DVERTEXELEMENT9 Decl[MAX_VERTEX_ELEMENTS];
        UINT64 DataOffset;
    };

    struct SDKMESH_INDEX_BUFFER_HEADER
    {
        UINT64 NumIndices;
        UINT64 SizeBytes;
        UINT IndexType;
        UINT64 DataOffset;
    };

    struct SDKMESH_MESH
    {
        char Name[MAX_MESH_NAME];
        BYTE NumVertexBuffers;
        UINT VertexBuffers[MAX_VERTEX_STREAMS];
        UINT IndexBuffer;
        UINT NumSubsets;
        UINT NumFrameInfluences; //aka bones

        DirectX::XMFLOAT3 BoundingBoxCenter;
        DirectX::XMFLOAT3 BoundingBoxExtents;

        UINT64 SubsetOffset;
        UINT64 FrameInfluenceOffset;
    };

    struct SDKMESH_SUBSET
    {
        char Name[MAX_SUBSET_NAME];
        UINT MaterialID;
        UINT PrimitiveType;
        UINT64 IndexStart;
        UINT64 IndexCount;
        UINT64 VertexStart;
        UINT64 VertexCount;
    };

    struct SDKMESH_FRAME
    {
        char Name[MAX_FRAME_NAME];
        UINT Mesh;
        UINT ParentFrame;
        UINT ChildFrame;
        UINT SiblingFrame;
        DirectX::XMFLOAT4X4 Matrix;
        UINT AnimationDataIndex;		//Used to index which set of keyframes transforms this frame
    };

    struct SDKMESH_MATERIAL
    {
        char    Name[MAX_MATERIAL_NAME];

        // Use MaterialInstancePath
        char    MaterialInstancePath[MAX_MATERIAL_PATH];

        // Or fall back to d3d8-type materials
        char    DiffuseTexture[MAX_TEXTURE_NAME];
        char    NormalTexture[MAX_TEXTURE_NAME];
        char    SpecularTexture[MAX_TEXTURE_NAME];

        DirectX::XMFLOAT4 Diffuse;
        DirectX::XMFLOAT4 Ambient;
        DirectX::XMFLOAT4 Specular;
        DirectX::XMFLOAT4 Emissive;
        FLOAT Power;

        UINT64 Force64_1;
        UINT64 Force64_2;
        UINT64 Force64_3;
        UINT64 Force64_4;
        UINT64 Force64_5;
        UINT64 Force64_6;
    };

    struct SDKANIMATION_FILE_HEADER
    {
        UINT Version;
        BYTE IsBigEndian;
        UINT FrameTransformType;
        UINT NumFrames;
        UINT NumAnimationKeys;
        UINT AnimationFPS;
        UINT64 AnimationDataSize;
        UINT64 AnimationDataOffset;
    };

    struct SDKANIMATION_DATA
    {
        DirectX::XMFLOAT3 Translation;
        DirectX::XMFLOAT4 Orientation;
        DirectX::XMFLOAT3 Scaling;
    };

    struct SDKANIMATION_FRAME_DATA
    {
        char FrameName[MAX_FRAME_NAME];
        UINT64 DataOffset;
    };

#pragma pack(pop)

}; // namespace

static_assert(sizeof(DXUT::D3DVERTEXELEMENT9) == 8, "Direct3D9 Decl structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_HEADER) == 104, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_VERTEX_BUFFER_HEADER) == 288, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_INDEX_BUFFER_HEADER) == 32, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_MESH) == 224, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_SUBSET) == 144, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_FRAME) == 184, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKMESH_MATERIAL) == 1256, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKANIMATION_FILE_HEADER) == 40, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKANIMATION_DATA) == 40, "SDK Mesh structure size incorrect");
static_assert(sizeof(DXUT::SDKANIMATION_FRAME_DATA) == 112, "SDK Mesh structure size incorrect");


//---------------------------------------------------------------------------------
static HRESULT LoadDataFromFile( _In_z_ const wchar_t* fileName,
                                 std::unique_ptr<uint8_t[]>& data,
                                 size_t& dataSize, bool anim )
{
    // open the file
#if (_WIN32_WINNT >= 0x0602 /*_WIN32_WINNT_WIN8*/)
    ScopedHandle hFile( safe_handle( CreateFile2( fileName,
                                                  GENERIC_READ,
                                                  FILE_SHARE_READ,
                                                  OPEN_EXISTING,
                                                  nullptr ) ) );
#else
    ScopedHandle hFile( safe_handle( CreateFileW( fileName,
                                                  GENERIC_READ,
                                                  FILE_SHARE_READ,
                                                  nullptr,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  nullptr ) ) );
#endif
    if ( !hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Get the file size
    LARGE_INTEGER FileSize = {0};

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
    FILE_STANDARD_INFO fileInfo;
    if ( !GetFileInformationByHandleEx( hFile.get(), FileStandardInfo, &fileInfo, sizeof(fileInfo) ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    FileSize = fileInfo.EndOfFile;
#else
    GetFileSizeEx( hFile.get(), &FileSize );
#endif

    // File is too big for 32-bit allocation, so reject read
    if( FileSize.HighPart > 0 )
    {
        return E_FAIL;
    }

    // Need at least enough data to fill the header
    if ( anim )
    {
        if( FileSize.LowPart < sizeof(DXUT::SDKANIMATION_FILE_HEADER) )
        {
            return E_FAIL;
        }
    }
    else
    {
        if( FileSize.LowPart < sizeof(DXUT::SDKMESH_HEADER) )
        {
            return E_FAIL;
        }
    }

    // create enough space for the file data
    data.reset( new (std::nothrow) uint8_t[ FileSize.LowPart ] );
    if ( !data )
    {
        return E_OUTOFMEMORY;
    }

    // read the data in
    DWORD BytesRead = 0;
    if( !ReadFile( hFile.get(), data.get(), FileSize.LowPart, &BytesRead, NULL ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if( BytesRead < FileSize.LowPart )
    {
        return E_FAIL;
    }

    dataSize = FileSize.LowPart;

    return S_OK;
}


//---------------------------------------------------------------------------------
bool DumpAnimation( const wchar_t* fname, const uint8_t* meshData, size_t dataSize )
{
    using namespace DXUT;

    auto header = reinterpret_cast<const SDKANIMATION_FILE_HEADER *>( meshData );

    if ( header->IsBigEndian )
    {
        wprintf( L"ERROR: This tool does not support BigEndian SDKMESH_ANIM files\n" );
        return false;
    }

    if ( header->Version != SDKMESH_FILE_VERSION )
    {
        wprintf( L"ERROR: Unsupported SDKMESH_ANIN file version %u. Requires %u\n", header->Version, SDKMESH_FILE_VERSION );
        return false;
    }

    if ( !header->NumFrames )
    {
        wprintf( L"ERROR: No frames found\n" );
        return false;
    }

    if ( !header->NumAnimationKeys )
    {
        wprintf( L"ERROR: No keys found\n" );
        return false;
    }

    const wchar_t* type = nullptr;
    switch( header->FrameTransformType )
    {
    case FTT_RELATIVE: type = L"Relative"; break;
    case FTT_ABSOLUTE: type = L"Absolute"; break;

    default:
        wprintf( L"ERROR: Unknown frame transform type %u\n", header->FrameTransformType );
        return false;
    }

    wprintf( L"ANIM %ls\n\tVersion %u, %ls\n\t%u frames, %u keys, %ls, %u FPS\n", fname,
             header->Version, (header->IsBigEndian) ? L"BigEndian" : L"LittleEndian",
             header->NumFrames, header->NumAnimationKeys, type, header->AnimationFPS );

    if ( dataSize < header->AnimationDataOffset
         || ( dataSize < (header->AnimationDataOffset + header->NumFrames * sizeof(SDKANIMATION_FRAME_DATA) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for animation frames\n" );
        return false;
    }

    auto frameArray = reinterpret_cast<const SDKANIMATION_FRAME_DATA*>( meshData + header->AnimationDataOffset );
    
    for( UINT j = 0; j < header->NumFrames; ++j )
    {
        wprintf(L"\t Frame %u '%hs'\n", j, frameArray[j].FrameName );

        size_t base = size_t(frameArray[j].DataOffset) + sizeof( SDKANIMATION_FILE_HEADER );

        if ( dataSize < base
             || ( dataSize < ( base + header->NumAnimationKeys * sizeof(SDKANIMATION_DATA) ) ) )
        {
            wprintf( L"ERROR: Not enough data in file for animation key\n" );
            return false;
        }
    }

    return true;
}


//---------------------------------------------------------------------------------
void DumpDecl( const DXUT::D3DVERTEXELEMENT9* decl, size_t max )
{
    using namespace DXUT;

    for( size_t j = 0; j < max; ++j )
    {
        if ( decl[j].Usage == 0xFF )
            break;

        if ( decl[j].Type == D3DDECLTYPE_UNUSED )
            break;

        if ( decl[j].Method != 0 )
        {
            wprintf(L"WARNING: Direct3D9 era tessellation not supported, method %u\n", decl[j].Method);
        }

        const wchar_t* usage = nullptr;
        switch( decl[j].Usage )
        {
        case D3DDECLUSAGE_POSITION: usage = L"POSITION"; break;
        case D3DDECLUSAGE_BLENDWEIGHT: usage = L"BLENDWEIGHT"; break;
        case D3DDECLUSAGE_BLENDINDICES: usage = L"BLENDINDICES"; break;
        case D3DDECLUSAGE_NORMAL: usage = L"NORMAL"; break;
        case D3DDECLUSAGE_TEXCOORD: usage = L"TEXCOORD"; break;
        case D3DDECLUSAGE_TANGENT: usage = L"TANGENT"; break;
        case D3DDECLUSAGE_BINORMAL: usage = L"BINORMAL"; break;
        case D3DDECLUSAGE_COLOR: usage = L"COLOR"; break;
        default: usage = L"*Uknown*"; break;
        }

        const wchar_t* format = nullptr;
        switch( decl[j].Type )
        {
        case D3DDECLTYPE_FLOAT1: format = L"DXGI_FORMAT_R32_FLOAT"; break;
        case D3DDECLTYPE_FLOAT2: format = L"DXGI_FORMAT_R32G32_FLOAT"; break;
        case D3DDECLTYPE_FLOAT3: format = L"DXGI_FORMAT_R32G32B32_FLOAT"; break;
        case D3DDECLTYPE_FLOAT4: format = L"DXGI_FORMAT_R32G32B32A32_FLOAT"; break;
        case D3DDECLTYPE_D3DCOLOR: format = L"DXGI_FORMAT_B8G8R8A8_UNORM"; break;
        case D3DDECLTYPE_UBYTE4: format = L"DXGI_FORMAT_R8G8B8A8_UINT"; break;
        case D3DDECLTYPE_UBYTE4N: format = L"DXGI_FORMAT_R8G8B8A8_UNORM"; break;
        case D3DDECLTYPE_SHORT4N: format = L"DXGI_FORMAT_R16G16B16A16_SNORM"; break;
        case D3DDECLTYPE_DEC3N: format = L"*D3DDECLTYPE_DEC3N*"; break;
        case D3DDECLTYPE_FLOAT16_2: format = L"DXGI_FORMAT_R16G16_FLOAT"; break;
        case D3DDECLTYPE_FLOAT16_4: format = L"DXGI_FORMAT_R16G16B16A16_FLOAT"; break;
        default: format = L"*Unknown*"; break;
        }

        wprintf( L"\t\t\"%ls\", %u, %ls, %u, %u\n", usage, decl[j].UsageIndex, format, decl[j].Stream, decl[j].Offset );
    }
}


//---------------------------------------------------------------------------------
template<typename index_t>
static void DumpIB( UINT id, const index_t* ib, size_t count, bool full )
{
    bool ellipsis = false;

    size_t nFaces = count / 3;

    size_t lowbound = 5;
    size_t hibound = ( nFaces > 5 ) ? ( nFaces - 5 ) : 0;

    wprintf(L"\tIB #%u - %Iu indices (%Iu faces) %ls\n", id, count, nFaces, (sizeof(index_t) == 2) ? L"IT_16BIT" : L"IT_32BIT");

    if ( !full )
        return;

    const index_t* iptr = ib;
    for( size_t j = 0; j < nFaces; ++j, iptr += 3 )
    {
        if ( ( j >= lowbound ) && (j < hibound ) )
        {
            if ( !ellipsis )
            {
                ellipsis = true;
                wprintf( L"\t ...\n" );
            }
            continue;
        }

        wprintf( L"\t %6Iu:\t%u, %u, %u\n", j+1, *iptr, *(iptr+1), *(iptr+2) );
    }
}


//---------------------------------------------------------------------------------
bool DumpMesh( const wchar_t* fname, const uint8_t* meshData, size_t dataSize, bool fulldump )
{
    using namespace DXUT;

    auto header = reinterpret_cast<const SDKMESH_HEADER *>( meshData );
    
    size_t headerSize = sizeof( SDKMESH_HEADER )
                        + header->NumVertexBuffers * sizeof(SDKMESH_VERTEX_BUFFER_HEADER)
                        + header->NumIndexBuffers * sizeof(SDKMESH_INDEX_BUFFER_HEADER);
    if ( header->HeaderSize != headerSize )
    {
        wprintf( L"ERROR: Not a valid SDKMESH file\n" );
        return false;
    }

    if ( dataSize < headerSize )
    {
        wprintf( L"ERROR: Not enough data in file for header\n" );
        return false;
    }

    if ( header->IsBigEndian )
    {
        wprintf( L"ERROR: This tool does not support BigEndian SDKMESH files\n" );
        return false;
    }

    if ( header->Version != SDKMESH_FILE_VERSION )
    {
        wprintf( L"ERROR: Unsupported SDKMESH file version %u. Requires %u\n", header->Version, SDKMESH_FILE_VERSION );
        return false;
    }

    if ( !header->NumMeshes )
    {
        wprintf( L"ERROR: No meshes found\n" );
        return false;
    }

    if ( !header->NumVertexBuffers )
    {
        wprintf( L"ERROR: No VBs found\n" );
        return false;
    }

    if ( !header->NumIndexBuffers )
    {
        wprintf( L"ERROR: No IBs found\n" );
        return false;
    }

    if ( !header->NumTotalSubsets )
    {
        wprintf( L"ERROR: No subsets found\n" );
        return false;
    }

    if ( !header->NumMaterials )
    {
        wprintf( L"ERROR: No materials found\n" );
        return false;
    }

    wprintf( L"SDKMESH %ls\n\tVersion %u, %ls\n\t%u meshes, %u VBs, %u IBs, %u subsets, %u frames, %u materials\n", fname,
             header->Version, (header->IsBigEndian) ? L"BigEndian" : L"LittleEndian",
             header->NumMeshes, header->NumVertexBuffers, header->NumIndexBuffers, header->NumTotalSubsets, header->NumFrames, header->NumMaterials );

    // Sub-headers
    if ( dataSize < header->VertexStreamHeadersOffset
         || ( dataSize < (header->VertexStreamHeadersOffset + header->NumVertexBuffers * sizeof(SDKMESH_VERTEX_BUFFER_HEADER) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for sub-headers\n" );
        return false;
    }
    auto vbArray = reinterpret_cast<const SDKMESH_VERTEX_BUFFER_HEADER*>( meshData + header->VertexStreamHeadersOffset );
    
    if ( dataSize < header->IndexStreamHeadersOffset
         || ( dataSize < (header->IndexStreamHeadersOffset + header->NumIndexBuffers * sizeof(SDKMESH_INDEX_BUFFER_HEADER) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for sub-headers\n" );
        return false;
    }
    auto ibArray = reinterpret_cast<const SDKMESH_INDEX_BUFFER_HEADER*>( meshData + header->IndexStreamHeadersOffset );

    if ( dataSize < header->MeshDataOffset
         || ( dataSize < (header->MeshDataOffset + header->NumMeshes * sizeof(SDKMESH_MESH) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for sub-headers\n" );
        return false;
    }
    auto meshArray = reinterpret_cast<const SDKMESH_MESH*>( meshData + header->MeshDataOffset );

    if ( dataSize < header->SubsetDataOffset
         || ( dataSize < (header->SubsetDataOffset + header->NumTotalSubsets * sizeof(SDKMESH_SUBSET) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for sub-headers\n" );
        return false;
    }
    auto subsetArray = reinterpret_cast<const SDKMESH_SUBSET*>( meshData + header->SubsetDataOffset );

    if ( dataSize < header->FrameDataOffset
         || (dataSize < (header->FrameDataOffset + header->NumFrames * sizeof(SDKMESH_FRAME) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for sub-headers\n" );
        return false;
    }
    auto frameArray = reinterpret_cast<const SDKMESH_FRAME*>( meshData + header->FrameDataOffset );

    if ( dataSize < header->MaterialDataOffset
         || (dataSize < (header->MaterialDataOffset + header->NumMaterials * sizeof(SDKMESH_MATERIAL) ) ) )
    {
        wprintf( L"ERROR: Not enough data in file for sub-headers\n" );
        return false;
    }
    auto materialArray = reinterpret_cast<const SDKMESH_MATERIAL*>( meshData + header->MaterialDataOffset );

    // Buffer data
    uint64_t bufferDataOffset = header->HeaderSize + header->NonBufferDataSize;
    if ( ( dataSize < bufferDataOffset )
         || ( dataSize < bufferDataOffset + header->BufferDataSize ) )
    {
        wprintf( L"ERROR: Not enough data in file for buffer data\n" );
        return false;
    }
    const uint8_t* bufferData = meshData + bufferDataOffset; 

    // Vertex Buffers
    for( UINT j=0; j < header->NumVertexBuffers; ++j )
    {
        auto& vh = vbArray[j];

        if ( dataSize < vh.DataOffset
             || ( dataSize < vh.DataOffset + vh.SizeBytes ) )
        {
            wprintf( L"ERROR: Not enough data in file for VB\n" );
            return false;
        }
   
        wprintf( L"\tVB #%u - %I64u vertices, %I64u stride\n", j, vh.NumVertices, vh.StrideBytes );

        DumpDecl( vh.Decl, MAX_VERTEX_ELEMENTS );
    }

    // Index Buffers
    for( UINT j=0; j < header->NumIndexBuffers; ++j )
    {
        auto& ih = ibArray[j];

        if ( dataSize < ih.DataOffset
             || ( dataSize < ih.DataOffset + ih.SizeBytes ) )
        {
            wprintf( L"ERROR: Not enough data in file for IB\n" );
            return false;
        }

        auto indices = reinterpret_cast<const uint8_t*>( bufferData + (ih.DataOffset - bufferDataOffset) );

        switch( ih.IndexType )
        {
        case DXUT::IT_16BIT:
            DumpIB( j, reinterpret_cast<const uint16_t*>( indices ), static_cast<size_t>( ih.NumIndices ), fulldump );
            break;

        case DXUT::IT_32BIT:
            DumpIB( j, reinterpret_cast<const uint32_t*>( indices ), static_cast<size_t>( ih.NumIndices ), fulldump );
            break;

        default:
            wprintf( L"WARNING: Unknown index type for IB #%u", j );
            break;
        }
    }

    // Meshes
    wprintf( L"\tMeshes\n" );

    for( UINT meshIndex = 0; meshIndex < header->NumMeshes; ++meshIndex )
    {
        auto& mh = meshArray[ meshIndex ];

        if ( !mh.NumSubsets
             || !mh.NumVertexBuffers
             || mh.IndexBuffer >= header->NumIndexBuffers
             || mh.VertexBuffers[0] >= header->NumVertexBuffers )
        {
            wprintf( L"WARNING: Invalid mesh '%hs' found - #%u\n", mh.Name, meshIndex );
        }
        else
        {
            wchar_t str[128] = {0};

            for( size_t j = 0; j < mh.NumVertexBuffers; ++j )
            {
                wchar_t tmp[32];
                swprintf_s( tmp, L" %u", mh.VertexBuffers[ j ] );
                wcscat_s( str, tmp );
            }

            wprintf( L"\t Mesh #%u '%hs'\n\t\t%u VBs [%ls ], %u IB, %u subsets, %u bones\n", meshIndex, mh.Name,
                     mh.NumVertexBuffers, str, mh.IndexBuffer, mh.NumSubsets, mh.NumFrameInfluences );

            wprintf( L"\t\tBoundsMin: (%f,%f,%f)\n",
                      mh.BoundingBoxCenter.x - mh.BoundingBoxExtents.x, mh.BoundingBoxCenter.y - mh.BoundingBoxExtents.y, mh.BoundingBoxCenter.z - mh.BoundingBoxExtents.z );
            wprintf( L"\t\tBoundsMax: (%f,%f,%f)\n",
                      mh.BoundingBoxCenter.x + mh.BoundingBoxExtents.x, mh.BoundingBoxCenter.y + mh.BoundingBoxExtents.y, mh.BoundingBoxCenter.z + mh.BoundingBoxExtents.z );

            if ( dataSize < mh.SubsetOffset
                 || (dataSize < mh.SubsetOffset + mh.NumSubsets*sizeof(UINT) ) )
            {
                wprintf( L"ERROR: Not enough data in file for subset\n" );
                return false;
            }

            auto subsets = reinterpret_cast<const UINT*>( meshData + mh.SubsetOffset );

            wprintf( L"\t\tSubsets (%u):\n", mh.NumSubsets );

            for( UINT j = 0; j < mh.NumSubsets; ++j )
            {
                auto sIndex = subsets[ j ];
                if ( sIndex >= header->NumTotalSubsets )
                {
                    wprintf( L"ERROR: Invalid subset reference found (%u, %u)\n", sIndex, header->NumTotalSubsets );
                    return false;
                }
                else
                {
                    auto& subset = subsetArray[ sIndex ];

                    const wchar_t* primType = nullptr;
                    switch( subset.PrimitiveType )
                    {
                    case DXUT::PT_TRIANGLE_LIST:        primType = L"TriangleList"; break;
                    case DXUT::PT_TRIANGLE_STRIP:       primType = L"TriangleStrip"; break;
                    case DXUT::PT_LINE_LIST:            primType = L"LineList"; break;
                    case DXUT::PT_LINE_STRIP:           primType = L"LineStrip"; break;
                    case DXUT::PT_POINT_LIST:           primType = L"PointList"; break;
                    case DXUT::PT_TRIANGLE_LIST_ADJ:    primType = L"TriangleListAdj"; break;
                    case DXUT::PT_TRIANGLE_STRIP_ADJ:   primType = L"TriangleStripAdj"; break;
                    case DXUT::PT_LINE_LIST_ADJ:        primType = L"LineListAdj"; break;
                    case DXUT::PT_LINE_STRIP_ADJ:       primType = L"LineStripAdj"; break;

                    case DXUT::PT_QUAD_PATCH_LIST:
                    case DXUT::PT_TRIANGLE_PATCH_LIST:
                        wprintf( L"ERROR: Direct3D9 era tessellation not supported, found in subset %u '%hs'\n", sIndex, subset.Name);
                        break;

                    default:
                        primType = L"*Unknown*";
                        break;
                    }

                    if ( primType )
                    {
                        if ( subset.MaterialID >= header->NumMaterials )
                        {
                            wprintf( L"WARNING: Subset %u '%hs' has invalid material index (%u, %u)\n", sIndex, subset.Name, subset.MaterialID, header->NumMaterials );
                        }
                        else
                        {
                            wprintf( L"\t\t Subset %u '%hs'\n\t\t\t material %u, %ls\n\t\t\tindex start %I64u, index count %I64u\n\t\t\tvertex start %I64u, vertex count %I64u\n", sIndex, subset.Name,
                                    subset.MaterialID, primType, subset.IndexStart, subset.IndexCount, subset.VertexStart, subset.VertexCount );
                        }
                    }
                }
            }

            if ( mh.NumFrameInfluences > 0 )
            {
                if ( dataSize < mh.FrameInfluenceOffset
                     || (dataSize < mh.FrameInfluenceOffset + mh.NumFrameInfluences*sizeof(UINT) ) )
                {
                    wprintf( L"ERROR: Not enough data in file for frame influences\n" );
                    return false;
                }

                auto influences = reinterpret_cast<const UINT*>( meshData + mh.FrameInfluenceOffset );

                for( UINT j = 0; j < mh.NumFrameInfluences; ++j )
                {
                    if ( influences[j] >= header->NumFrames )
                    {
                        wprintf( L"ERROR: Invalid frame influence reference (%u)\n", influences[j] );
                        return false;
                    }

                    if ( fulldump )
                    {
                        // TO DO - 
                    }
                }
            }
        }
    }

    wprintf( L"\tMaterials\n" );

    for( UINT matIndex = 0; matIndex < header->NumMaterials; ++matIndex )
    {
        auto& mat = materialArray[ matIndex ];

        wprintf( L"\t Material %u '%hs'\n", matIndex, mat.Name );

        if ( !fulldump )
            continue;

        if ( *mat.MaterialInstancePath )
        {
            wprintf( L"\t\t Path: '%hs'\n", mat.MaterialInstancePath );
        }

        if ( *mat.DiffuseTexture )
        {
            wprintf( L"\t\t Diffuse: '%hs'\n", mat.DiffuseTexture );
        }

        if ( *mat.NormalTexture )
        {
            wprintf( L"\t\t Normal: '%hs'\n", mat.NormalTexture );
        }

        if ( *mat.SpecularTexture )
        {
            wprintf( L"\t\t Specular: '%hs'\n", mat.SpecularTexture );
        }

        wprintf(L"\t\t A: (%f, %f, %f, %f)\n\t\t D: (%f, %f, %f, %f)\n\t\t S: (%f, %f, %f, %f) ^%f\n\t\t E: (%f, %f, %f, %f)\n",
                mat.Ambient.x, mat.Ambient.y, mat.Ambient.z, mat.Ambient.w, 
                mat.Diffuse.x, mat.Diffuse.y, mat.Diffuse.z, mat.Diffuse.w,
                mat.Specular.x, mat.Specular.y, mat.Specular.z, mat.Specular.w, mat.Power,
                mat.Emissive.x, mat.Emissive.y, mat.Emissive.z, mat.Emissive.w );

    }

    if ( header->NumFrames > 0 )
    {
        wprintf( L"\tFrames\n" );

        for( UINT j = 0; j < header->NumFrames; ++j )
        {
            auto& frame = frameArray[ j ];

            wprintf( L"\t Frame %u '%hs'\n", j, frame.Name );

            if ( frame.Mesh != INVALID_MESH && frame.Mesh >= header->NumMeshes )
            {
                wprintf( L"ERROR: Invalid frame mesh reference (%u)\n", frame.Mesh );
                return false;
            }

            if ( frame.ParentFrame != INVALID_FRAME && frame.ParentFrame >= header->NumFrames )
            {
                wprintf( L"ERROR: Invalid frame parent reference (%u)\n", frame.ParentFrame );
                return false;
            }

            if ( frame.ChildFrame != INVALID_FRAME && frame.ChildFrame >= header->NumFrames )
            {
                wprintf( L"ERROR: Invalid frame child reference (%u)\n", frame.ChildFrame );
                return false;
            }

            if ( frame.SiblingFrame != INVALID_FRAME && frame.SiblingFrame >= header->NumFrames )
            {
                wprintf( L"ERROR: Invalid frame sibling reference (%u)\n", frame.SiblingFrame );
                return false;
            }

            if ( fulldump )
            {
                if ( frame.ParentFrame != INVALID_FRAME )
                    wprintf( L"\t\t Parent: %u ('%hs')\n", frame.ParentFrame, frameArray[ frame.ParentFrame ].Name );

                if ( frame.ChildFrame != INVALID_FRAME )
                    wprintf( L"\t\t Child: %u ('%hs')\n", frame.ChildFrame, frameArray[ frame.ChildFrame ].Name );

                if ( frame.SiblingFrame != INVALID_FRAME )
                    wprintf( L"\t\t Sibling: %u ('%hs')\n", frame.SiblingFrame, frameArray[ frame.SiblingFrame ].Name );

                if ( frame.Mesh != INVALID_MESH )
                {
                    wprintf( L"\t\t Mesh %u ('%hs')\n", frame.Mesh, meshArray[ frame.Mesh ].Name );
                }

                if ( frame.AnimationDataIndex != INVALID_ANIMATION_DATA )
                {
                    wprintf( L"\t\t Animation %u\n", frame.AnimationDataIndex );
                }

                // TO DO - 
            }
        }
    }

    return true;
}


//---------------------------------------------------------------------------------
int wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ]  )
{
    UNREFERENCED_PARAMETER( envp );
    if ( argc != 2 && argc != 3 )
    {
       wprintf( L"Usage: %ls <filename.sdkmesh> | <filename.sdkmesh_anim> [-full]\n", argv[0] );
       return -1;
    }

    bool fulldump = false;

    if ( argc == 3 )
    {
        if ( !_wcsicmp( argv[2], L"-full" ) || !_wcsicmp( argv[2], L"/full" ) )
        {
            fulldump = true;
        }
        else
        {
            wprintf( L"ERROR: Unknown switch '%ls'\n", argv[2] );
            return -1;
        }
    }

    bool isanim = false;
    {
        WCHAR ext[_MAX_EXT];
        _wsplitpath_s( argv[1], nullptr, 0, nullptr, 0, nullptr, 0, ext, _MAX_EXT );

        if ( !_wcsicmp( ext, L".sdkmesh_anim" ) )
            isanim = true;
    }

    size_t dataSize = 0;
    std::unique_ptr<uint8_t[]> data;
    HRESULT hr = LoadDataFromFile( argv[1], data, dataSize, isanim );
    if(FAILED(hr))
    {
        wprintf( L"ERROR: failed to load %ls\n", argv[1] );
        return -1;
    }

    if ( isanim )
    {
        if ( !DumpAnimation( argv[1], data.get(), dataSize ) )
            return -1;
    }
    else
    {
        if ( !DumpMesh( argv[1], data.get(), dataSize, fulldump ) )
            return -1;
    }
    
    return 0;
}
