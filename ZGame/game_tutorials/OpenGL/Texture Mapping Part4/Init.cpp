//***********************************************************************//
//																		 //
//		- "Talk to me like I'm a 3 year old!" Programming Lessons -		 //
//                                                                       //
//		$Author:		DigiBen		digiben@gametutorials.com			 //
//																		 //
//		$Program:		TexturingIV										 //
//																		 //
//		$Description:	Texture maps a QUAD with a TGA image			 //
//																		 //
//***********************************************************************//

#include "main.h"


/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *


///////////////////////////////// LOAD TGA \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This loads the TGA file and returns it's data in a tImageTGA struct
/////
///////////////////////////////// LOAD TGA \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

tImageTGA *LoadTGA(const char *filename)
{
    tImageTGA *pImageData = NULL;		// This stores our important image data
    WORD width = 0, height = 0;			// The dimensions of the image
    byte length = 0;					// The length in bytes to the pixels
    byte imageType = 0;					// The image type (RLE, RGB, Alpha...)
    byte bits = 0;						// The bits per pixel for the image (16, 24, 32)
    FILE *pFile = NULL;					// The file pointer
    int channels = 0;					// The channels of the image (3 = RGA : 4 = RGBA)
    int stride = 0;						// The stride (channels * width)
    int i = 0;							// A counter

    // This function loads in a TARGA (.TGA) file and returns its data to be
    // used as a texture or what have you.  This currently loads in a 16, 24
    // and 32-bit targa file, along with RLE compressed files.  Eventually you
    // will want to do more error checking to make it more robust.  This is
    // also a perfect start to go into a modular class for an engine.
    // Basically, how it works is, you read in the header information, then
    // move your file pointer to the pixel data.  Before reading in the pixel
    // data, we check to see the if it's an RLE compressed image.  This is because
    // we will handle it different.  If it isn't compressed, then we need another
    // check to see if we need to convert it from 16-bit to 24 bit.  24-bit and
    // 32-bit textures are very similar, so there's no need to do anything special.
    // We do, however, read in an extra bit for each color.

    // Open a file pointer to the targa file and check if it was found and opened
    if((pFile = fopen(filename, "rb")) == NULL)
    {
        // Display an error message saying the file was not found, then return NULL
        MessageBox(g_hWnd, "Unable to load TGA File!", "Error", MB_OK);
        return NULL;
    }

    // Allocate the structure that will hold our eventual image data (must free it!)
    pImageData = (tImageTGA*)malloc(sizeof(tImageTGA));

    // Read in the length in bytes from the header to the pixel data
    fread(&length, sizeof(byte), 1, pFile);

    // Jump over one byte
    fseek(pFile,1,SEEK_CUR);

    // Read in the imageType (RLE, RGB, etc...)
    fread(&imageType, sizeof(byte), 1, pFile);

    // Skip past general information we don't care about
    fseek(pFile, 9, SEEK_CUR);

    // Read the width, height and bits per pixel (16, 24 or 32)
    fread(&width,  sizeof(WORD), 1, pFile);
    fread(&height, sizeof(WORD), 1, pFile);
    fread(&bits,   sizeof(byte), 1, pFile);

    // Now we move the file pointer to the pixel data
    fseek(pFile, length + 1, SEEK_CUR);

    // Check if the image is RLE compressed or not
    if(imageType != TGA_RLE)
    {
        // Check if the image is a 24 or 32-bit image
        if(bits == 24 || bits == 32)
        {
            // Calculate the channels (3 or 4) - (use bits >> 3 for more speed).
            // Next, we calculate the stride and allocate enough memory for the pixels.
            channels = bits / 8;
            stride = channels * width;
            pImageData->data = new unsigned char[stride * height];

            // Load in all the pixel data line by line
            for(int y = 0; y < height; y++)
            {
                // Store a pointer to the current line of pixels
                unsigned char *pLine = &(pImageData->data[stride * y]);

                // Read in the current line of pixels
                fread(pLine, stride, 1, pFile);

                // Go through all of the pixels and swap the B and R values since TGA
                // files are stored as BGR instead of RGB (or use GL_BGR_EXT verses GL_RGB)
                for(i = 0; i < stride; i += channels)
                {
                    int temp     = pLine[i];
                    pLine[i]     = pLine[i + 2];
                    pLine[i + 2] = temp;
                }
            }
        }
        // Check if the image is a 16 bit image (RGB stored in 1 unsigned short)
        else if(bits == 16)
        {
            unsigned short pixels = 0;
            int r=0, g=0, b=0;

            // Since we convert 16-bit images to 24 bit, we hardcode the channels to 3.
            // We then calculate the stride and allocate memory for the pixels.
            channels = 3;
            stride = channels * width;
            pImageData->data = new unsigned char[stride * height];

            // Load in all the pixel data pixel by pixel
            for(int i = 0; i < width*height; i++)
            {
                // Read in the current pixel
                fread(&pixels, sizeof(unsigned short), 1, pFile);

                // To convert a 16-bit pixel into an R, G, B, we need to
                // do some masking and such to isolate each color value.
                // 0x1f = 11111 in binary, so since 5 bits are reserved in
                // each unsigned short for the R, G and B, we bit shift and mask
                // to find each value.  We then bit shift up by 3 to get the full color.
                b = (pixels & 0x1f) << 3;
                g = ((pixels >> 5) & 0x1f) << 3;
                r = ((pixels >> 10) & 0x1f) << 3;

                // This essentially assigns the color to our array and swaps the
                // B and R values at the same time.
                pImageData->data[i * 3 + 0] = r;
                pImageData->data[i * 3 + 1] = g;
                pImageData->data[i * 3 + 2] = b;
            }
        }
        // Else return a NULL for a bad or unsupported pixel format
        else
            return NULL;
    }
    // Else, it must be Run-Length Encoded (RLE)
    else
    {
        // First, let me explain real quickly what RLE is.
        // For further information, check out Paul Bourke's intro article at:
        // http://astronomy.swin.edu.au/~pbourke/dataformats/rle/
        //
        // Anyway, we know that RLE is a basic type compression.  It takes
        // colors that are next to each other and then shrinks that info down
        // into the color and a integer that tells how much of that color is used.
        // For instance:
        // aaaaabbcccccccc would turn into a5b2c8
        // Well, that's fine and dandy and all, but how is it down with RGB colors?
        // Simple, you read in an color count (rleID), and if that number is less than 128,
        // it does NOT have any optimization for those colors, so we just read the next
        // pixels normally.  Say, the color count was 28, we read in 28 colors like normal.
        // If the color count is over 128, that means that the next color is optimized and
        // we want to read in the same pixel color for a count of (colorCount - 127).
        // It's 127 because we add 1 to the color count, as you'll notice in the code.

        // Create some variables to hold the rleID, current colors read, channels, & stride.
        byte rleID = 0;
        int colorsRead = 0;
        channels = bits / 8;
        stride = channels * width;

        // Next we want to allocate the memory for the pixels and create an array,
        // depending on the channel count, to read in for each pixel.
        pImageData->data = new unsigned char[stride * height];
        byte *pColors = new byte [channels];

        // Load in all the pixel data
        while(i < width*height)
        {
            // Read in the current color count + 1
            fread(&rleID, sizeof(byte), 1, pFile);

            // Check if we don't have an encoded string of colors
            if(rleID < 128)
            {
                // Increase the count by 1
                rleID++;

                // Go through and read all the unique colors found
                while(rleID)
                {
                    // Read in the current color
                    fread(pColors, sizeof(byte) * channels, 1, pFile);

                    // Store the current pixel in our image array
                    pImageData->data[colorsRead + 0] = pColors[2];
                    pImageData->data[colorsRead + 1] = pColors[1];
                    pImageData->data[colorsRead + 2] = pColors[0];

                    // If we have a 4 channel 32-bit image, assign one more for the alpha
                    if(bits == 32)
                        pImageData->data[colorsRead + 3] = pColors[3];

                    // Increase the current pixels read, decrease the amount
                    // of pixels left, and increase the starting index for the next pixel.
                    i++;
                    rleID--;
                    colorsRead += channels;
                }
            }
            // Else, let's read in a string of the same character
            else
            {
                // Minus the 128 ID + 1 (127) to get the color count that needs to be read
                rleID -= 127;

                // Read in the current color, which is the same for a while
                fread(pColors, sizeof(byte) * channels, 1, pFile);

                // Go and read as many pixels as are the same
                while(rleID)
                {
                    // Assign the current pixel to the current index in our pixel array
                    pImageData->data[colorsRead + 0] = pColors[2];
                    pImageData->data[colorsRead + 1] = pColors[1];
                    pImageData->data[colorsRead + 2] = pColors[0];

                    // If we have a 4 channel 32-bit image, assign one more for the alpha
                    if(bits == 32)
                        pImageData->data[colorsRead + 3] = pColors[3];

                    // Increase the current pixels read, decrease the amount
                    // of pixels left, and increase the starting index for the next pixel.
                    i++;
                    rleID--;
                    colorsRead += channels;
                }

            }

        }

        // Free up pColors
        delete[] pColors;
    }

    // Close the file pointer that opened the file
    fclose(pFile);

    // Fill in our tImageTGA structure to pass back
    pImageData->channels = channels;
    pImageData->sizeX    = width;
    pImageData->sizeY    = height;

    // Return the TGA data (remember, you must free this data after you are done)
    return pImageData;
}

/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *


///////////////////////////////// CREATE TEXTURE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This creates a texture in OpenGL that we can use as a texture map
/////
///////////////////////////////// CREATE TEXTURE \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

void CreateTexture(UINT textureArray[], LPSTR strFileName, int textureID)
{
    if(!strFileName)									// Return from the function if no file name was passed in
        return;

/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *

    // Just like the other image loaders, we return a pointer to some image data,
    // which needs to be freed once we are finished with it, along with it's data.

    tImageTGA *pImage = LoadTGA(strFileName);			// Load the image and store the data

/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *


    if(pImage == NULL)									// If we can't load the file, quit!
        exit(0);

    // Generate a texture with the associative texture ID stored in the array
    glGenTextures(1, &textureArray[textureID]);

    // Bind the texture to the texture arrays index and init the texture
    glBindTexture(GL_TEXTURE_2D, textureArray[textureID]);


/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *

    // Assume that the texture is a 24 bit RGB texture (We convert 16-bit ones to 24-bit)
    int textureType = GL_RGB;

    // If the image is 32-bit (4 channels), then we need to specify GL_RGBA for an alpha
    if(pImage->channels == 4)
        textureType = GL_RGBA;

    // Build Mipmaps (builds different versions of the picture for distances - looks better)
    gluBuild2DMipmaps(GL_TEXTURE_2D, pImage->channels, pImage->sizeX,
                      pImage->sizeY, textureType, GL_UNSIGNED_BYTE, pImage->data);

/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *


    // Lastly, we need to tell OpenGL the quality of our texture map.  GL_LINEAR_MIPMAP_LINEAR
    // is the smoothest.  GL_LINEAR_MIPMAP_NEAREST is faster than GL_LINEAR_MIPMAP_LINEAR,
    // but looks blochy and pixilated.  Good for slower computers though.

    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);

    // Now we need to free the image data that we loaded since OpenGL stored it as a texture

    if (pImage)										// If we loaded the image
    {
        if (pImage->data)							// If there is texture data
        {
            delete[] pImage->data;					// Free the texture data, we don't need it anymore
        }

        free(pImage);								// Free the image structure
    }
}


///////////////////////////////// CHANGE TO FULL SCREEN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This changes the screen to FULL SCREEN
/////
///////////////////////////////// CHANGE TO FULL SCREEN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

void ChangeToFullScreen()
{
    DEVMODE dmSettings;									// Device Mode variable

    memset(&dmSettings,0,sizeof(dmSettings));			// Makes Sure Memory's Cleared

    // Get current settings -- This function fills in our settings.
    // This makes sure NT and Win98 machines change correctly.
    if(!EnumDisplaySettings(NULL,ENUM_CURRENT_SETTINGS,&dmSettings))
    {
        // Display error message if we couldn't get display settings
        MessageBox(NULL, "Could Not Enum Display Settings", "Error", MB_OK);
        return;
    }

    dmSettings.dmPelsWidth	= SCREEN_WIDTH;				// Selected Screen Width
    dmSettings.dmPelsHeight	= SCREEN_HEIGHT;			// Selected Screen Height

    // This function actually changes the screen to full screen.
    // CDS_FULLSCREEN gets rid of the start Bar.
    // We always want to get a result from this function to check if we failed.
    int result = ChangeDisplaySettings(&dmSettings,CDS_FULLSCREEN);

    // Check if we didn't receive a good return message From the function
    if(result != DISP_CHANGE_SUCCESSFUL)
    {
        // Display the error message and quit the program
        MessageBox(NULL, "Display Mode Not Compatible", "Error", MB_OK);
        PostQuitMessage(0);
    }
}

///////////////////////////////// CREATE MY WINDOW \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This function creates a window, but doesn't have a message loop
/////
///////////////////////////////// CREATE MY WINDOW \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

HWND CreateMyWindow(LPSTR strWindowName, int width, int height, DWORD dwStyle, bool bFullScreen, HINSTANCE hInstance)
{
    HWND hWnd;
    WNDCLASS wndclass;

    memset(&wndclass, 0, sizeof(WNDCLASS));				// Init the size of the class
    wndclass.style = CS_HREDRAW | CS_VREDRAW;			// Regular drawing capabilities
    wndclass.lpfnWndProc = WinProc;						// Pass our function pointer as the window procedure
    wndclass.hInstance = hInstance;						// Assign our hInstance
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);	// General icon
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);		// An arrow for the cursor
    wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);	// A white window
    wndclass.lpszClassName = "GameTutorials";			// Assign the class name

    RegisterClass(&wndclass);							// Register the class

    if(bFullScreen && !dwStyle) 						// Check if we wanted full screen mode
    {
        // Set the window properties for full screen mode
        dwStyle = WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
        ChangeToFullScreen();							// Go to full screen
        ShowCursor(FALSE);								// Hide the cursor
    }
    else if(!dwStyle)									// Assign styles to the window depending on the choice
        dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

    g_hInstance = hInstance;							// Assign our global hInstance to the window's hInstance

    RECT rWindow;
    rWindow.left	= 0;								// Set Left Value To 0
    rWindow.right	= width;							// Set Right Value To Requested Width
    rWindow.top	    = 0;								// Set Top Value To 0
    rWindow.bottom	= height;							// Set Bottom Value To Requested Height

    AdjustWindowRect( &rWindow, dwStyle, false);		// Adjust Window To True Requested Size

    // Create the window
    hWnd = CreateWindow("GameTutorials", strWindowName, dwStyle, 0, 0,
                        rWindow.right  - rWindow.left, rWindow.bottom - rWindow.top,
                        NULL, NULL, hInstance, NULL);

    if(!hWnd) return NULL;								// If we could get a handle, return NULL

    ShowWindow(hWnd, SW_SHOWNORMAL);					// Show the window
    UpdateWindow(hWnd);									// Draw the window

    SetFocus(hWnd);										// Sets Keyboard Focus To The Window

    return hWnd;
}

///////////////////////////////// SET UP PIXEL FORMAT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This function sets the pixel format for OpenGL.
/////
///////////////////////////////// SET UP PIXEL FORMAT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

bool bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd;
    int pixelformat;

    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);			// Set the size of the structure
    pfd.nVersion = 1;									// Always set this to 1
    // Pass in the appropriate OpenGL flags
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.dwLayerMask = PFD_MAIN_PLANE;					// We want the standard mask (this is ignored anyway)
    pfd.iPixelType = PFD_TYPE_RGBA;						// We want RGB and Alpha pixel type
    pfd.cColorBits = SCREEN_DEPTH;						// Here we use our #define for the color bits
    pfd.cDepthBits = SCREEN_DEPTH;						// Depthbits is ignored for RGBA, but we do it anyway
    pfd.cAccumBits = 0;									// No special bitplanes needed
    pfd.cStencilBits = 0;								// We desire no stencil bits

    // This gets us a pixel format that best matches the one passed in from the device
    if ( (pixelformat = ChoosePixelFormat(hdc, &pfd)) == FALSE )
    {
        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    // This sets the pixel format that we extracted from above
    if (SetPixelFormat(hdc, pixelformat, &pfd) == FALSE)
    {
        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    return TRUE;										// Return a success!
}

//////////////////////////// RESIZE OPENGL SCREEN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This function resizes the viewport for OpenGL.
/////
//////////////////////////// RESIZE OPENGL SCREEN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
void SizeOpenGLScreen(int width, int height)			// Initialize The GL Window
{
    if (height==0)										// Prevent A Divide By Zero error
    {
        height=1;										// Make the Height Equal One
    }

    glViewport(0,0,width,height);						// Make our viewport the whole window
    // We could make the view smaller inside
    // Our window if we wanted too.
    // The glViewport takes (x, y, width, height)
    // This basically means, what are our drawing boundaries

    glMatrixMode(GL_PROJECTION);						// Select The Projection Matrix
    glLoadIdentity();									// Reset The Projection Matrix

    // Calculate The Aspect Ratio Of The Window
    // The parameters are:
    // (view angle, aspect ration of the width to the height,
    //  the closest distance to the camera before it clips,
    // FOV		// Ratio				//  the farthest distance before it stops drawing).
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height, .5f ,150.0f);

    glMatrixMode(GL_MODELVIEW);							// Select The Modelview Matrix
    glLoadIdentity();									// Reset The Modelview Matrix
}

///////////////////////////////// INITIALIZE GL \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This function handles all the initialization for OpenGL.
/////
///////////////////////////////// INITIALIZE GL \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

void InitializeOpenGL(int width, int height)
{
    g_hDC = GetDC(g_hWnd);								// This sets our global HDC
    // We don't free this hdc until the end of our program
    if (!bSetupPixelFormat(g_hDC))						// This sets our pixel format/information
        PostQuitMessage (0);							// If there's an error, quit

    g_hRC = wglCreateContext(g_hDC);					// This creates a rendering context from our hdc
    wglMakeCurrent(g_hDC, g_hRC);						// This makes the rendering context we just created the one we want to use

/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *

    // This allows us to use texture mapping, otherwise we just use colors.

    glEnable(GL_TEXTURE_2D);							// Enable Texture Mapping

/////// * /////////// * /////////// * NEW * /////// * /////////// * /////////// *

    SizeOpenGLScreen(width, height);					// Setup the screen translations and viewport
}


///////////////////////////////// DE INIT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This function cleans up and then posts a quit message to the window
/////
///////////////////////////////// DE INIT \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

void DeInit()
{
    if (g_hRC)
    {
        wglMakeCurrent(NULL, NULL);						// This frees our rendering memory and sets everything back to normal
        wglDeleteContext(g_hRC);						// Delete our OpenGL Rendering Context
    }

    if (g_hDC)
        ReleaseDC(g_hWnd, g_hDC);						// Release our HDC from memory

    if(g_bFullScreen)									// If we were in full screen
    {
        ChangeDisplaySettings(NULL,0);					// If So Switch Back To The Desktop
        ShowCursor(TRUE);								// Show Mouse Pointer
    }

    UnregisterClass("GameTutorials", g_hInstance);		// Free the window class

    PostQuitMessage (0);								// Post a QUIT message to the window
}


///////////////////////////////// WIN MAIN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
/////
/////	This function handles registering and creating the window.
/////
///////////////////////////////// WIN MAIN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hprev, PSTR cmdline, int ishow)
{
    HWND hWnd;

    // Check if we want full screen or not
    if(MessageBox(NULL, "Click Yes to go to full screen (Recommended)", "Options", MB_YESNO | MB_ICONQUESTION) == IDNO)
        g_bFullScreen = false;

    // Create our window with our function we create that passes in the:
    // name, width, height, any flags for the window, if we want fullscreen of not, and the hInstance.
    hWnd = CreateMyWindow("www.GameTutorials.com - Texture Mapping TGAs", SCREEN_WIDTH, SCREEN_HEIGHT, 0, g_bFullScreen, hInstance);

    // If we never got a valid window handle, quit the program
    if(hWnd == NULL) return TRUE;

    // INIT OpenGL
    Init(hWnd);

    // Run our message loop and after it's done, return the result
    return MainLoop();
}


/////////////////////////////////////////////////////////////////////////////////
//
// * QUICK NOTES *
//
// In this version of our texture mapping tutorials, we added a TGA loader.  In
// main.h you will find the tImageTGA structure that will contain the image info.
// Only 1 new function was added to this tutorial:
//
// tImageTGA *LoadTGA(const char *filename);
//
//
// Ben Humphrey (DigiBen)
// Game Programmer
// DigiBen@GameTutorials.com
// ©2000-2005 GameTutorials
//
//
